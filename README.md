# FPGA ASCII Text Editor

Project done for the Digital Design Concepts Lab @ Group T - Faculty of Engineering Technology / academic year 2021-22

### Authors:
* [@avidadearthur](https://github.com/avidadearthur)
* Kamran Poladov

## Description
The project consists of a VGA controller that displays ASCII characters on a monitor based what buttons the user presses.

## Features
* Bidirectional control of characters selection
* Switch the color from green to blue and the other way around
* Add a whitespace
* Clear the entire screen

## Instructions
* BTN0    - Next character
* BTN1    - Previous Character
* BTN2    - Puts current character to the screen
* BTN2 x2 - Puts whitespace to the screen 
* BTN3    - Clears the screen (reset)
* SW0     - Switches the text color from green to blue and vice versa

## Background and details
### VGA – Video Graphics Array
The VGA standard was developed by IBM in the late 80s. It features a three row, 15-pin connector that carries analog RGBHV video signals: Red, Green, Blue, Horizontal sync and Vertical sync. Several resolutions are supported by VGA. In this lab, we will use a 640x480 pixel resolution, refreshed at a rate of 60Hz, and with support for 12 bpp (bits per pixel: 4 red, 4 green and 4 blue).

Modern VGA displays can accommodate different resolutions, and a VGA controller circuit dictates the resolution by producing timing signals to control the raster patterns. The pattern starts at the top left of the screen and starts moving to the right until it reaches the end of the drawable screen and restarts one pixel row lower at the left. When the cotroller reaches the bottom of the screen it goes back to the top left corner.

### How is it done?
Through Digital VGA Controller. The goal of a digital VGA controller circuit is to generate two signals: the HS (horizontal sync) and the VS (vertical sync) timings signals - as well as to coordinate the delivery of RGB video data.

* The HS signal defines how many pixels are in one screen line. It indicates to the display when to start drawing a new line.

* The VS signal defines the number of lines of the screen. It thus defines the “refresh” frequency of the display, or the frequency at which all information on the display is redrawn.

* Video information (i.e. the RGB values corresponding to a pixel) are only relevant when the display area is active. This corresponds to the DRAW area as shown below. In the remaining areas, necessary for the horizontal/vertical blankings (resetting the beam position), the display area is inactive. In this region, the RGB signals are set to zero. The inactive area consists of three sub-areas: FP (front porch), SYNC (sync pulse) and BP (back porch). Their duration is different depending on whether they relate to horizontal or vertical blanking periods

### VGA Timings

In the first lab we target a display resolution of 640x480 pixels for the active area (or draw region). The ‘effective’ resolution, when we include the blanking period areas, will be in total 800x525 pixels. The length of the FP, SYNC and BP for horizontal and vertical timings are:

FPh = 16 pixels
SYNCh = 96 pixels
BPh = 48 pixels
	
FPv = 10 lines
SYNCv = 2 lines
BPv = 33 lines

From these numbers, it follows that to generate one frame on the display we will have to go through 800x525 = 420k pixels. Given that we want a refresh rate of 60Hz (or 60 frames per second) the amount of pixels to cover each second will be 420k * 60 = 25.2 million. Hence a 25.2 MHz pixel clock is needed in order to implement the design with these parameters.

In our FPGA design we will use a frequency of 25 MHz for the pixel clock (using a Clock Wizard, as shown previously), which will work just fine.

### Architecture for the VGA Controller

The top-level view of the digital VGA Controller we will build has the following IO:

- iClk is a 25 MHz clock input, generated by the Clock Wizard inside the Pynq-Z2
- iRst is an active-high synchronous reset, implemented through a push button in the Pynq-Z2

- oHS is the horizontal sync output signal
- oVS is the vertical sync output signal
- oRed is the red component of the video data output, 4 bits wide
- oGreen is the green component of the video data, 4 bits wide
- oBlue is the blue component of the video data, 4 bits wide

Internally, the VGA Controller will consist of two modules:

1. VGA Timings is a sequential circuit that generates the horizontal/vertical sync output signals (oHS and oVS). It internally contains two counters that keep track of the current position in the display: the row and column for the current pixel. The values of these two counters (oCountH and oCountV) are an output of this module.
	
2. VGA Patterns is a combinational circuit that generates the RGB signals for the VGA display. Based on the current position of the pixel (row + column) provided by the VGA timings module, it will decide which color pattern needs to be generated. For the active area region, this can be any 12-bit color. For the inactive area region (or blanking regions) this is required to be all zeroes

### 1. VGA Timings Code
```
    // HORIZONTAL COUNTER IMPLAMENTATION
    //
    // The oCountH should be incremented from 0 to 656 with oHS set to 1,
    // then from pixel 656 to 752 oHS is set to 0 (SYNCh) and, finnaly from 752
    // up to 800 it is set to 1 again.
	
	localparam H_LIM = ( WIDTH + H_FP + H_PW + H_BP ) - 1;

    // The internal comparator
	
	assign H_w_Cmp = ( H_r_CntCurr == H_LIM );

    // The internal reset occur on external reset(iRst) OR
    // on the H_LIM comparison(H_w_Cmp)
	
	assign H_w_Rst = ( iRst | H_w_Cmp );
    
    // GENERATE HORIZONTAL SYNC (oHS)
    // Change Output Horizontal Sync by comparing the counter value 
    // with the pulse width
	
	assign oHS = ( H_r_CntCurr >= ( WIDTH + H_FP ) && H_r_CntCurr < ( WIDTH + H_FP + H_PW )) ? 0 : 1;


    // VERTICAL COUNTER IMPLAMENTATION
    //
    // The oCountV should be incremented from 0 to 490 with oVS set to 1,
    // then from pixel 490 to 492 oHS is set to 0 (SYNCh) and, finnaly from 492
    // up to 525 it is set to 1 again.
    // The important difference here is that the increments should only occur 
    // when a line has been completed ( oCountH == H_LIM )

    // GENERATE VERTICAL SYNC (oVS)
    // Change Output Vertical Sync by comparing the counter value 
    // with the pulse width
    	
	assign oVS = ( V_r_CntCurr >= ( HEIGHT + V_FP ) && V_r_CntCurr < ( HEIGHT + V_FP + V_PW )) ? 0 : 1;       
```
### 2. VGA Patterns Code
```
    // The Horizontal Counter (iCountH) and the Vertical Counter (iCountV) have been 
    // programed to go respectively up to 640 and 480 cycles, which are the drawing area
    // limits of our monitor.
    //
    // Here, the original counter values are being modified to help us internally remap 
    // the original resolution of the monitor (640x480) to simulate a grid of 40x15 cells. 
    // Each cell will be 16x32 pixels and will be able to hold a character. 
    // (Note that 640 = 40 cells x 16 pixels and 480 = 15 cells x 32 pixels).
    //
    // Note that the divisions by integers here work discarting the floating points,
    // so BlockH will be 0 until iCountH has counted 16 pixels, then it will be 1 until
    // iCount has counted 32 pixels. BlockV, in turn, will be 0 until iCountV has counted
    // 32 lines and so on...
    
	wire [5:0] BlockH = iCountH / 16; // 0 --> 39 unit grids
	wire [5:0] BlockV = iCountV / 32; // 0 --> 14 unit grids

    // oAddrA is the connection to ScreenBufferMem through iAddrA and it will ask
    // this simplified Dual-Port RAM to output the bit-value content stored at the line
    // with decimal number corresponding to oAddrA (0 --> 599).
    
	assign oAddrA = BlockV * 40 + BlockH;

    // This bit-value output will leave ScreenBufferMem through oDataA and be fed back
    // to VGA_pattern at iDataA. But what does iDataA contain?
    // It contains the start of the base address of a character at AsciiCharsMem memory.
    //
    // What is happening here is that we are picking this address iDataA and giving to oAdrrA2
    // which is connected to the AsciiCharsMem memory.
    // And we will keep doing so with the next 31 pixel bit lines of data. That is done using
    // the same Horizontal Counter (iCountH) and the Vertical Counter (iCountV).

    // check drawable limits
    	
	wire LIM = (iCountH <= WIDTH && iCountV <= HEIGHT) ? 1 : 0;
    
    // We use iCountV % 32 here because the modulo operation here offers us a 0 to 31
    // that keeps looping and always happens to be zero when a new pixel row on the screen is 
    // displayed.
    	
	assign oAddrA2 = (LIM)? iDataA + (iCountV % 32) : 0;

    // When oAddrA2 sends the start of the base address of a character to iAddr at AsciiCharsMem memory
    // That module will return back the bit-value content of that line. Every bit corresponds to a pixel
    // and if it is 1 it should be collored and if it is 0 it should be left blank.
    // (pixel bit lines)
    //
    // The logic we use here is similar to the pixel bit line loop counter (0-->31) but since we are
    // coloring the pixels from left to right and the characters are 16 pixels wide we use the indexing
    // [15 - (iCountH % 16)]

    	assign oRed   = (LIM) ? 0: 0;
    	assign oGreen = (LIM && ~iColor) ? 15 * (iDataA2[ 15 - (iCountH % 16) ]) : 0;
    	assign oBlue  = (LIM && iColor) ? 15 * (iDataA2[ 15 - (iCountH % 16) ]) : 0;
```
### 4. FSM code
See [here](https://github.com/avidadearthur/DDC-Lab/blob/main/FSM.pdf) for the FSM diagram.
```
    //This is the FSM module. it connects to Port B of the 
    // ScreenBufferMem, in order to update which characters
    // are displayed on the screen and at which position.

    // The design has 5 inputs: iClk (25 MHz), 
    // iRst (connected to push button BTN3), iPush (connected to
    // push button BTN1), iPull (connected to push button BTN2) 
    // and iStop (connected to push button BTN3).
    
    // The module outputs a data stream (oData) that can access all the 
    // ASCII adresses in the memory file. And a memory address (oAddr) 
    // that maps one of the 600 possible cells on the screen.
    // 
    // Thus, for the final assignment we'll have as outputs:
    // oAddr - one of the 600 cells that can hold a character on the screen
    // oData - the number that corresponds to the first line of a character
    //         in the ASCII memory file.
    // oWe   - Write enable to write to ScreenBufferMem

    // 0. DEFINITION OF FSM STATES:
    //

    	localparam sInit      = 4'b0000; // s0
    	localparam sIdle      = 4'b0001; // s1
    	localparam sPush      = 4'b0010; // s2
    	localparam sChange    = 4'b0011; // s3
    	localparam sUnChange  = 4'b0100; // s4
    	localparam sAddr      = 4'b0101; // s5
    	localparam sRstNum    = 4'b0110; // s6
    	localparam sSet       = 4'b0111; // s7
    	localparam sPull      = 4'b1000; // s8
    	localparam sData      = 4'b1001; // s9


  // 3. OUTPUT LOGIC:
  //
  // CHARACTER COUNTER REGISTERS
  //
  // This register pair keeps track of the number of inputs on the iPush 
  // or iPull buttons. In contrast to the LED 
  // toggling example, this register is now 7-bits long such that it
  // can be used to calculate any of the 94 characters in the ASCII memory file.
  // 
  
	reg signed [6:0] rNumberCurr, rNumberNext;


  // START OF ASYNCHRONOUS OPPERATIONS
  //
  // Init table position at '@' symbol to avoid
  // having to press too many times.
  
	localparam tablepos = 1024;
 
  // Convert the number from 0 - 94 to address line number in memory file
  
	assign oData =  (rFSM_current == sData)? tablepos + 32 * rNumberNext : 0;
  	assign oAddr =  (rFSM_current == sData)? rAddr : 0;

  // Equivalent to sychronous assignment:
  // if (rFSM_current == sData) : rWe   <= 1;
  	
	assign oWe   =  (rFSM_current == sData)? 1 : 0;
```
### 5. The testbench
```
INCREASE TWO CARACTERS AND DISPLAY
/////////////////////////////////////////////////////
    
    // #1st Push
    rPush = 1;      // assert push
    #(5*T);         // wait
    rPush = 0;      // de-assert push
    
    // #2nd Push
    #(5*T);         // wait
    rPush = 1;      // assert push
    #(5*T);         // wait
    rPush = 0;      // de-assert push
    
    
    // #Display
    #(5*T);         // wait
    rStop = 1;      // assert Stop
    #(5*T);         // wait
    rStop = 0;      // de-assert Stop
    

////////////////////////////////////////////////////////


INCREASE ONE CARACTER AND DISPLAY
////////////////////////////////////////////////////////

    // #1st Push
    #(5*T);         // wait
    rPush = 1;      // assert push
    #(5*T);         // wait
    rPush = 0;      // de-assert push
    
    // #Display
    #(5*T);         // wait
    rStop = 1;      // assert Stop
    #(5*T);         // wait
    rStop = 0;      // de-assert Stop

////////////////////////////////////////////////////////


DISPLAY SPCAE ETWEEN CHARACTERS
////////////////////////////////////////////////////////
    
    // #IStop 2x to display Space
    #(5*T);         // wait
    rStop = 1;      // assert Stop
    #(5*T);         // wait
    rStop = 0;      // de-assert Stop
    // #Display
    #(5*T);         // wait
    rStop = 1;      // assert Stop
    #(5*T);         // wait
    rStop = 0;      // de-assert Stop

////////////////////////////////////////////////////////


INCREASE TWO CARACTERS AND DECREASE TWO CARACTERS
AND DISPLAY
////////////////////////////////////////////////////////

    // Push 2x Pull 2x and display
    // #1st Push
    #(5*T);
    rPush = 1;      // assert push
    #(5*T);         // wait
    rPush = 0;      // de-assert push
    
    // #2nd Push
    #(5*T);         // wait
    rPush = 1;      // assert push
    #(5*T);         // wait
    rPush = 0;      // de-assert push
    
    // #1st Pull
    #(5*T);
    rPull = 1;      // assert push
    #(5*T);         // wait
    rPull = 0;      // de-assert push
    
    // #2nd Pull
    #(5*T);         // wait
    rPull = 1;      // assert push
    #(5*T);         // wait
    rPull = 0;      // de-assert push
    
    // #Display
    #(5*T);         // wait
    rStop = 1;      // assert Stop
    #(5*T);         // wait
    rStop = 0;      // de-assert Stop

////////////////////////////////////////////////////////

CLEAR SCREEN
////////////////////////////////////////////////////////
    
    // Reset screen
    #(5*T);
    rRst = 1;       // assert reset
    #(2*T);         // wait
    rRst = 0;       // de-assert reset
    #(5*T);         // wait

////////////////////////////////////////////////////////
```
